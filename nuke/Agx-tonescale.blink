// version 5
// The tonescale curve for AgX
// to apply on log-encoded imagery (unless u_log_convert is true)
//
// All equations are from Troy Sobotka and Jed Smith work :
// https://github.com/sobotka/AgX-S2O3/blob/main/AgX.py

kernel AgXTonescale : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeClamped> src;
    Image<eWrite> dst;

    param:
        float u_min_EV;
        float u_max_EV;
        float u_general_contrast;
        float2 u_limits_contrast;
        bool u_log_convert;
        float u_log_midgrey;

    local:
        float g_x_pivot;
        float g_y_pivot;

    void define() {
        defineParam(u_min_EV, "u_min_EV", -10.0f);
        defineParam(u_max_EV, "u_max_EV", 6.5f);
        defineParam(u_general_contrast, "u_general_contrast", 2.0f);
        defineParam(u_limits_contrast, "u_limits_contrast", float2(3.0, 3.25));
        defineParam(u_log_midgrey, "u_log_midgrey", 0.18f);
    }

    void init() {
        g_x_pivot = fabs(u_min_EV / (u_max_EV - u_min_EV));
        g_y_pivot = 0.5;
    }

    float3 convert_open_domain_to_normalized_log2(float3 color){
        // Similar to OCIO lg2 AllocationTransform.
        // References:
        //     - [1] https://github.com/sobotka/AgX-S2O3/blob/main/AgX.py
        float3 mincolor(0.000001, 0.000001, 0.000001);
        float3 out = max(color, mincolor);
        float3 midgrey(u_log_midgrey, u_log_midgrey, u_log_midgrey);
        out = log2(color / midgrey);
        out = clamp(
            out,
            float3(u_min_EV, u_min_EV, u_min_EV),
            float3(u_max_EV, u_max_EV, u_max_EV)
        );
        return (out - u_min_EV) / (u_max_EV - u_min_EV);
    }

    float equation_scale(
        float x_pivot, float y_pivot, float slope_pivot, float power
    ){
        float a = pow(slope_pivot * x_pivot, -1.0 * power);
        float b = pow(slope_pivot * (x_pivot / y_pivot), power) - 1.0;
        return pow(a * b, -1.0 / power);
    }

    float equation_hyperbolic(float x, float power){
        return x / pow(1.0 + pow(x, power), 1.0 / power);
    }

    float equation_term(float x, float x_pivot, float slope_pivot, float scale){
        return (slope_pivot * (x - x_pivot)) / scale;
    }

    float equation_curve(float value, float scale){
        float a = equation_hyperbolic(
            equation_term(value, g_x_pivot, u_general_contrast, scale),
            u_limits_contrast.x
        );
        a = a * scale + g_y_pivot;

        float b = equation_hyperbolic(
            equation_term(value, g_x_pivot, u_general_contrast, scale),
            u_limits_contrast.y
        );
        b = b * scale + g_y_pivot;

        return scale < 0.0? a: b;

    }

    float equation_full_curve(float value){
        float scale_x_pivot = value >= g_x_pivot? 1.0 - g_x_pivot: g_x_pivot;
        float scale_y_pivot = value >= g_x_pivot? 1.0 - g_y_pivot: g_y_pivot;

        float toe_scale = equation_scale(
            scale_x_pivot,
            scale_y_pivot,
            u_general_contrast,
            u_limits_contrast.x
        );

        float shoulder_scale = equation_scale(
            scale_x_pivot,
            scale_y_pivot,
            u_general_contrast,
            u_limits_contrast.y
        );

        float scale = value >= g_x_pivot? shoulder_scale: -1.0 * toe_scale;

        return equation_curve(value, scale);
    }

    void process(int2 pos) {

        float4 rgba = src();

        float3 converted_rgb(rgba.x, rgba.y, rgba.z);

        if (u_log_convert){
            converted_rgb = convert_open_domain_to_normalized_log2(converted_rgb);
        }

        // apply per-channel tonescale curve
        converted_rgb.x = equation_full_curve(converted_rgb.x);
        converted_rgb.y = equation_full_curve(converted_rgb.y);
        converted_rgb.z = equation_full_curve(converted_rgb.z);

        dst() = float4(
            converted_rgb.x,
            converted_rgb.y,
            converted_rgb.z,
            rgba.w
        );
    }
};